{"meta":{"title":"博客|屿哲","subtitle":null,"description":"thinking in island","author":"Yuzhe Von","url":"http://yuzhe-tech.com"},"pages":[{"title":"","date":"2018-05-24T03:04:29.355Z","updated":"2018-05-24T03:04:29.355Z","comments":false,"path":"about/index.html","permalink":"http://yuzhe-tech.com/about/index.html","excerpt":"","text":"微信："},{"title":"categories","date":"2018-05-16T09:32:04.000Z","updated":"2018-05-21T08:38:43.830Z","comments":false,"path":"categories/index.html","permalink":"http://yuzhe-tech.com/categories/index.html","excerpt":"","text":"Java"},{"title":"书签","date":"2018-05-22T07:21:23.548Z","updated":"2018-05-22T07:21:23.548Z","comments":false,"path":"links/index.html","permalink":"http://yuzhe-tech.com/links/index.html","excerpt":"","text":"常用工具 json格式化在线工具 前台API W3CLayUIDatatablesjQuery模板AngularJS SwiperBootstraploading.io 后台API NutzHexoGithubEclipse 阅读 极客学院老D博客老鬼博客"},{"title":"我没有国度|我没有岛屿","date":"2018-05-22T10:16:00.285Z","updated":"2018-05-22T10:16:00.285Z","comments":false,"path":"myLife/index.html","permalink":"http://yuzhe-tech.com/myLife/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-16T09:42:39.000Z","updated":"2018-05-16T09:42:39.447Z","comments":true,"path":"tags/index.html","permalink":"http://yuzhe-tech.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"request","slug":"request","date":"2018-07-11T10:07:10.000Z","updated":"2018-07-11T10:27:06.564Z","comments":false,"path":"2018/07/11/request/","link":"","permalink":"http://yuzhe-tech.com/2018/07/11/request/","excerpt":"一 获取URL:getRequestURL() 二 获取参数列表:1.getQueryString()只适用于GET,比如客户端发送http://localhost/testServlet?a=b&amp;c=d&amp;e=f,通过request.getQueryString()得到的是a=b&amp;c=d&amp;e=f.","text":"一 获取URL:getRequestURL() 二 获取参数列表:1.getQueryString()只适用于GET,比如客户端发送http://localhost/testServlet?a=b&amp;c=d&amp;e=f,通过request.getQueryString()得到的是a=b&amp;c=d&amp;e=f. 2.getParameter()GET和POST都可以使用但如果是POST请求要根据表单提交数据的编码方式来确定能否使用.当编码方式是(application/x- www-form-urlencoded)时才能使用.这种编码方式(application/x-www-form-urlencoded)虽然简单，但对于传输大块的二进制数据显得力不从心.对于传输大块的二进制数这类数据，浏览器采用了另一种编码方式(“multipart/form-data”),这时就需要使用下面的两种方法. 3.getInputStream()4.getReader()上面两种方法获取的是Http请求包的包体,因为GET方式请求一般不包含包体.所以上面两种方法一般用于POST请求获取参数. 需要注意的是：request.getParameter()、 request.getInputStream()、request.getReader()这三种方法是有冲突的，因为流只能被读一次。比如：当form表单内容采用 enctype=application/x-www-form-urlencoded编码时，先通过调用request.getParameter()方法得到参数后,再调用request.getInputStream()或request.getReader()已经得不到流中的内容，因为在调用 request.getParameter()时系统可能对表单中提交的数据以流的形式读了一次,反之亦然。 当form表单内容采用 enctype=multipart/form-data编码时，即使先调用request.getParameter()也得不到数据，所以这时调用request.getParameter()方法对 request.getInputStream()或request.getReader()没有冲突，即使已经调用了 request.getParameter()方法也可以通过调用request.getInputStream()或request.getReader()得到表单中的数据,而request.getInputStream()和request.getReader()在同一个响应中是不能混合使用的,如果混合使用就会抛异常。 三 其他常用APIsetAttribute(String name,Object)：设置名字为name的request的参数值 getAttribute(String name)：返回由name指定的属性值 getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例 getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组 getCharacterEncoding()：返回请求中的字符编码方式 getContentLength()：返回请求的Body的长度 getHeader(String name)：获得HTTP协议定义的文件头信息 getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例 getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例 getInputStream()：返回请求的输入流，用于获得请求中的数据 getMethod()：获得客户端向服务器端传送数据的方法 getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值 getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 getParameterValues(String name)：获得有name指定的参数的所有值 getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 getQueryString()：获得查询字符串 getRequestURI()：获取发出请求字符串的客户端地址 getRemoteAddr()：获取客户端的IP地址 getRemoteHost()：获取客户端的名字 getSession([Boolean create])：返回和请求相关Session getServerName()：获取服务器的名字 getServletPath()：获取客户端所请求的脚本文件的路径 getServerPort()：获取服务器的端口号 removeAttribute(String name)：删除请求中的一个属性","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"jackson","slug":"jackson","date":"2018-07-11T02:26:28.000Z","updated":"2018-07-11T02:35:52.647Z","comments":false,"path":"2018/07/11/jackson/","link":"","permalink":"http://yuzhe-tech.com/2018/07/11/jackson/","excerpt":"导包&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt;","text":"导包&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; 将java对象转换成json字符串/** * 使用jackson api将java对象转换 * 成json字符串 * @throws JsonProcessingException */ public static void test1() throws JsonProcessingException{ Stock s = new Stock(); s.setCode(&quot;600877&quot;); s.setName(&quot;中国嘉陵&quot;); s.setPrice(8); //jackson api ObjectMapper om = new ObjectMapper(); String jsonStr = om.writeValueAsString(s); System.out.println(jsonStr); } public static void test2() throws JsonProcessingException{ List&lt;Stock&gt; stocks = new ArrayList&lt;Stock&gt;(); for(int i = 0; i &lt; 3; i ++){ Stock s = new Stock(); s.setCode(&quot;60087&quot; + i); s.setName(&quot;中国嘉陵&quot; + i); s.setPrice(8 + i); stocks.add(s); } ObjectMapper om = new ObjectMapper(); String jsonStr = om.writeValueAsString(stocks); System.out.println(jsonStr); }","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"JSONObject与JSONArray","slug":"JSONObject","date":"2018-07-09T15:05:47.000Z","updated":"2018-07-10T10:03:54.989Z","comments":false,"path":"2018/07/09/JSONObject/","link":"","permalink":"http://yuzhe-tech.com/2018/07/09/JSONObject/","excerpt":"需要导入一下jar包 &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 123import net.sf.json.JSONArray;import net.sf.json.JSONObject; 一：JSONObject创建JSONObject","text":"需要导入一下jar包 &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 123import net.sf.json.JSONArray;import net.sf.json.JSONObject; 一：JSONObject创建JSONObject 1.创建一个空的JSONObject对象JSONObject json=new JSONObject(); 2.创建一个不为null的JSONObject对象JSONObject json=new JSONObject(true); 3.创建一个为null的JSONObject对象JSONObject json=new JSONObject(false); 4.从一个字符串中创建一个JSONObject对象String str=&quot;{key1:value1,key2:value2}&quot;; JSONObject json=new JSONObject(str); 5.从一个Map对象中创建一个JSONObject对象Map&lt;Object, Object&gt; map=new HashMap&lt;Object, Object&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put( &quot;key3&quot;, new String[]{&quot;a&quot;,&quot;b&quot;} ); JSONObject json=new JSONObject(map); 常用方法boolean bool=json.isEmpty(); --//判断是否为空 boolean bool=json.isNullObject(); --//判断是否为空对象 json.put(&quot;key&quot;,&quot;value&quot;); --//向json中放入key和value json.put(String key,Object value); json.put(String key,boolean value); json.put(String key,double value); json.put(String key,int value); json.put(String key,long value); json.put(String key,Map value); Object obj=json.get(&quot;key&quot;); --//根据key得到Object类型的value值 boolean bool=json.getBoolean(&quot;key&quot;); --//根据key得到boolean类型的value值 double dou=json.getDouble(&quot;key&quot;); --//根据key得到double类型的value值 int it=json.getInt(&quot;key&quot;); --//根据key得到int类型的value值 String str=json.getString(&quot;key&quot;); --//根据key得到String类型的value值 long lng=json.getLong(&quot;key&quot;); --//根据key得到long类型的value值 JSONObject json1=json.getJSONObject(&quot;key&quot;); --//根据key得到JSONObject类型的value值 JSONArray jsonArr=json.getJSONArray(&quot;key&quot;); --//根据key得到JSONArray类型的value值 boolean bool=json.has(&quot;key&quot;) --//判断json中是否包含key这个键值 Iterator&lt;Object&gt; its=json.keys(); --//得到json中keys的迭代器 int it=json.length(); --//得到json的长度,即包含的key的个数 JSONObject的静态方法JSONObject json=JSONObject.fromMap(Map map);--//从一个MAP对象初始化JSONObject String str=&quot;{key1:value1,key2:value2}&quot;; JSONObject json=JSONObject.fromString(str); --//从一个字符串对象初始化JSONObject JSONObject json=JSONObject.fromObject(str); --//从一个Object对象来初始化JSONObject 二：JSONArray创建JSONArray对象1.创建一个空的JSONArray对象JSONArray jsonArr=new JSONArray(); 2.基于数组or集合创建一个JSONArray对象String[] strArr={&quot;value1&quot;,&quot;value2&quot;,&quot;value3&quot;}; //字符串数组 char[] chArr={&apos;a&apos;,&apos;b&apos;,&apos;c&apos;}; //字符数组 boolean[] boolArr={false,true,false}; //boolean数组 double[] douArr={12.1,10.1}; //double数组 float[] fltArr={12.3,7.8}; //float数组 int[] intArr={1,2,3}; //int数组 String str=&quot;[1,2,3]&quot;; //String字符串 List&lt;String&gt; list=new ArrayList&lt;String&gt;(); //list集合 list.add(&quot;value1&quot;); list.add(&quot;value2&quot;); JSONArray jsonArr=new JSONArray(strArr/chArr/boolArr/douArr/intArr/str/list); 常用方法boolean bool=jsonArr.isEmpty(); --//判断JSONArray是否为空 Object[] objArr=jsonArr.toArray(); --//将JSONArray转换成array数组 Object obj=jsonArr.get(int index); --//得到指定index下标的对象 boolean bool=jsonArr.getBoolean(int index); --//得到指定index下标的Boolean对象 double dou=jsonArr.getDouble(int index); --//得到指定index下标的double数据 int it=jsonArr.getInt(int index); --//得到指定index下标的int数据 String str=jsonArr.getString(int index); --//得到指定index下标的String数据 long lng=jsonArr.getLong(int index); --//得到指定index下标的long数据 JSONArray jsArr=jsonArr.getJSONArray(int index); --//得到指定index下标的JSONArray对象 JSONObject json=jsonArr.getJSONObject(int index); --//得到指定index下标的JSONObject对象 jsonArr.put(boolean value); --//将boolean值添加到JSONArray中 jsonArr.put(Collection value); --//将集合添加到JSONArray中 jsonArr.put(double value); --//将double值添加到JSONArray中 jsonArr.put(int value); --//将int值添加到JSONArray中 jsonArr.put(Long value); --//将long值添加到JSONArray中 jsonArr.put(Map value); --//将Map对象添加到JSONArray中 jsonArr.put(Object value); --//将Object对象添加到JSONArray中 jsonArr.put(int index,Object value); --//将指定的value值添加到指定的下标下 Iterator&lt;Object&gt; it=jsonArr.iteartor(); --//将JSONArray生成迭代器 JSONArray的静态方法Object[] objArr={1,2,3,4}; JSONArray.fromArray(ObjArr); --//从array数组中获取JSONArray List&lt;String&gt; list=new ArrayList&lt;String&gt;(); JSONArray.fromCollection(list); --//从list集合中获取JSONArray Object obj=&quot;[1,2,3,4]&quot;; JSONArray.fromObject(obj); --//从Object中获取JSONArray String str=&quot;[1,2,3,4]&quot;; JSONArray.fromString(str); --//从String字符串中获取JSONArray ​​​​​​​​​​​​​​​​​​","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"Exception-01","slug":"Exception-01","date":"2018-06-04T14:41:15.000Z","updated":"2018-07-04T10:28:46.855Z","comments":false,"path":"2018/06/04/Exception-01/","link":"","permalink":"http://yuzhe-tech.com/2018/06/04/Exception-01/","excerpt":"（一）异常机制中还有一个重要的部分，就是finally, catch后面可以跟finally语句，语法如下所示：try{ //可能抛出异常 }catch(Exception e){ //捕获异常 }finally{ //不管有无异常都执行 }","text":"（一）异常机制中还有一个重要的部分，就是finally, catch后面可以跟finally语句，语法如下所示：try{ //可能抛出异常 }catch(Exception e){ //捕获异常 }finally{ //不管有无异常都执行 } （二）finally内的代码不管有无异常发生，都会执行。具体来说：如果没有异常发生，在try内的代码执行结束后执行。如果有异常发生且被catch捕获，在catch内的代码执行结束后执行如果有异常发生但没被捕获，则在异常被抛给上层之前执行。由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。 try/catch/finally语法中，catch不是必需的，也就是可以只有try/finally，表示不捕获异常，异常自动向上传递，但finally中的代码在异常发生后也执行。 （三）finally语句有一个执行细节，如果在try或者catch语句内有return语句，则return语句在finally语句执行结束后才执行，但finally并不能改变返回值，我们来看下代码：public static int test(){ int ret = 0; try{ return ret; }finally{ ret = 2; } } 这个函数的返回值是0，而不是2，实际执行过程是，在执行到try内的return ret;语句前，会先将返回值ret保存在一个临时变量中，然后才执行finally语句，最后try再返回那个临时变量，finally中对ret的修改不会被返回。 （四）如果在finally中也有return语句呢？try和catch内的return会丢失，实际会返回finally中的返回值。finally中有return不仅会覆盖try和catch内的返回值，还会掩盖try和catch内的异常，就像异常没有发生一样，比如说：public static int test(){ int ret = 0; try{ int a = 5/0; return ret; }finally{ return 2; } } 以上代码中，5/0会触发ArithmeticException，但是finally中有return语句，这个方法就会返回2，而不再向上传递异常了。 （五）finally中不仅return语句会掩盖异常，如果finally中抛出了异常，则原异常就会被掩盖，看下面代码：public static void test(){ try{ int a = 5/0; }finally{ throw new RuntimeException(&quot;hello&quot;); } } finally中抛出了RuntimeException，则原异常ArithmeticException就丢失了。 一般而言，为避免混淆，应该避免在finally中使用return语句或者抛出异常，如果调用的其他代码可能抛出异常，则应该捕获异常并进行处理。","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"阿里巴巴Java开发手册","slug":"alibaba","date":"2017-11-04T15:05:47.000Z","updated":"2018-07-09T12:10:57.885Z","comments":false,"path":"2017/11/04/alibaba/","link":"","permalink":"http://yuzhe-tech.com/2017/11/04/alibaba/","excerpt":"","text":"《阿里巴巴Java开发手册》最新详尽版： 说明： 该书是阿里内部Java工程师所遵循的开发规范，涵盖编程规约、单元测试规约、异常日志规约、MySQL规约、工程规约、安全规约等。让我们一起码出高效、码出质量。","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"Spring","slug":"spring01","date":"2017-11-04T15:05:47.000Z","updated":"2018-07-04T10:29:49.851Z","comments":false,"path":"2017/11/04/spring01/","link":"","permalink":"http://yuzhe-tech.com/2017/11/04/spring01/","excerpt":"一、Spring概述开源的，用来简化企业级应用开发的应用开发框架。 我们学习Spring框架的最终目的是用它整合Struts2、Hibernate框架（SSH）。","text":"一、Spring概述开源的，用来简化企业级应用开发的应用开发框架。 我们学习Spring框架的最终目的是用它整合Struts2、Hibernate框架（SSH）。 1.1 Spring框架的作用Spring框架主要负责技术整合（可以整合很多技术），该框架提供IoC和AOP机制，基于这些特性整合，可以降低系统组件之间的耦合度，便于系统组件的维护、扩展和替换。 1.1.1 简化开发: spring对常用的一些api（比如jdbc）做了封装，​ 这样，代码会大大简化，而且代码质量也会提高（比如，使用​ spring jdbc访问数据库，就不用考虑获取连接与关闭连接）。 1.1.2 解耦: spring可以帮我们管理对象（帮我们创建对象并且管理​ 对象之间依赖关系)。这样一来，软件更容易维护。 1.1.3 集成: spring可以集成其它的一些框架（比如，集成任务调度的框架 Quartz等等）。 1.2 Spring框架的优点其实与Spring框架的作用相同： 在SSH中，主要是利用Spring容器管理我们程序中的Action、DAO等组件，通过容器的IoC机制，可以降低Action、DAO之间的耦合度（关联度），利用AOP进行事务管理等共通部分的处理。 在SSH中，Struts2主要是利用它的控制器，而不是标签、表达式；Hibernate主要利用它的数据库访问；Spring主要是利用它的整合。 1.3 Spring框架的容器​ Spring框架中的一个核心模块，用来管理对象。​ 注：管理对象：指的是创建对象、初始化、销毁以及管理对象之间​ 的依赖关系。 Spring框架的核心是提供了一个容器（是我们抽象出来的，代指后面的类型）。该容器类型是BeanFactory(接口)或ApplicationContext（接口）（建议用这个类型，它是BeanFactory的子类，功能更多）。 二、Spring容器的基本应用2.1如何将一个Bean组件交给Spring容器1）Bean组件其实就是个普通的Java类！ 2）方法：在applicationContext.xml中添加以下定义，见2.6案例中step4。 &lt;bean id=&quot;标识符&quot; class=&quot;Bean组件类型&quot;&gt;&lt;/bean&gt; 2.2如何获取Spring容器对象和Bean对象1）实例化容器： ApplicationContext ac=new ClassPathXmlApplicationContext(“/applicationContext.xml”); //FileSystemXmlApplicationContext(“”);//去指定的磁盘目录找，上面的为去Class路径找 2）利用getBean(“标识符”)方法获取容器中的Bean对象。见2.6案例中step5。 2.3如何控制对象创建的模式Spring支持singleton（单例）和prototype（原型，非单例）两种模式。 默认是singleton模式，可以通过的scope属性修改为prototype模式。以后在Web程序中，通过扩展可以使用request、session等值。见2.6案例中step4、step7。 例如： u 注意事项：对于NetCTOSS项目，一个请求创建一个Action，所以用Spring时必须指明prototype，否则默认使用singleton会出问题。而DAO则可用singleton模式。 2.4 Bean对象创建的时机1）singleton模式的Bean组件是在容器实例化时创建。 2）prototype模式是在调用getBean()方法时创建。 3）singleton模式可以使用元素的lazy-init=”true”属性将对象的创建时机推迟到调用getBean()方法。也可以在（根元素）中使用default-lazy-init=”false”推迟所有单例Bean组件的创建时机。见2.6案例中step3、step4。 例如： &lt;beans ...... default-lazy-init=&quot;false&quot;&gt;&lt;/beans&gt; 2.5为Bean对象执行初始化和销毁方法1）初始化：①可以利用元素的init-method=”方法名”属性指定初始化方法。 ②指定的初始化方法是在构造方法调用后自动执行。若非单例模式，则每创建一个对象，则执行一次初始化方法（单例、非单例模式都可）。见2.6案例中step3、step4。 u 注意事项： v 初始化的三种方式：写构造方法中；或写{ }中（代码块）；Spring框架中元素写init-method=”方法名”属性。 v 初始化不能用static{ }，它是类加载调用，比创建对象要早。 2）销毁：①可以利用元素的destroy-method=”方法名”属性执行销毁方法。 ②指定的销毁方法是在容器关闭时触发，而且只适用于singleton模式的组件（只能为单例模式）。见2.6案例中step3、step4、step6。 2.6案例：Spring框架的使用以及2.1节-2.5节整合测试step1：导入Spring开发包：spring.jar、commons-logging.jar和配置文件：applicationContext.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; step2：在org.tarena.dao包下，创建接口CostDAO，添加两个方法 public void delete(); public void save(); step3：在org.tarena.dao包下，创建JdbcCostDAO类，并实现CostDAO接口 public JdbcCostDAO(){ System.out.println(“创建CostDAO对象”); } public void myinit(){ System.out.println(“初始化CostDAO对象”); } public void mydestroy(){ System.out.println(“销毁CostDAO对象”); } public void delete() { System.out.println(“利用JDBC技术实现删除资费记录”); } public void save() { System.out.println(“利用JDBC技术实现保存资费记录”); } step4：在applicationContext.xml配置文件中，将Bean组件（Java类）交给Spring容器 step5：在org.tarena.test包下，创建TestApplicationContext类，获取Spring容器对象，并测试 @Test public void test1(){ String conf=”/applicationContext.xml”; ​ ApplicationContext ac=new ClassPathXmlApplicationContext(conf);//实例化容器 ​ CostDAO costDAO=(CostDAO)ac.getBean(“jdbcCostDAO”);//获取Bean对象 ​ costDAO.save(); costDAO.delete(); } step6：在TestApplicationContext类中添加方法，测试销毁对象 @Test /*关闭容器才会触发销毁，但关闭容器方法封装在AbstractApplicationContext类中 / public void test2(){ String conf=”/applicationContext.xml”; ​ ApplicationContext ac=new ClassPathXmlApplicationContext(conf); ​ AbstractApplicationContext ac=new ClassPathXmlApplicationContext(conf); ​ CostDAO costDAO=(CostDAO)ac.getBean(“jdbcCostDAO”); ac.close(); } step7：在TestApplicationContext类中添加方法，测试单例 ​ @Test ​ public void test3(){ String conf=”/applicationContext.xml”; ​ ApplicationContext ac= new ClassPathXmlApplicationContext(conf); ​ CostDAO costDAO1=(CostDAO)ac.getBean(“jdbcCostDAO”); ​ CostDAO costDAO2=(CostDAO)ac.getBean(“jdbcCostDAO”); ​ System.out.println(costDAO1==costDAO2);//true，所以Spring默认为单例模式 }","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"BD_CHECK","slug":"BD-CHECK","date":"2017-08-17T12:10:06.000Z","updated":"2018-07-09T12:23:33.961Z","comments":false,"path":"2017/08/17/BD-CHECK/","link":"","permalink":"http://yuzhe-tech.com/2017/08/17/BD-CHECK/","excerpt":"BD赢家拓客上线检查数据记录123456781.分享数据tookeen_share2.活动数据tookeen_activity3.所有的数据都要匹配到agent和wxUser4.数据记录三级分类，tookeen_share和tookeen_activty5.试算记录tookeen_calc，source为3表示当月热荐，source为1私人定制， source为2产品分享，insuranceTitle过长会造成客户清单显示不全。6.根据编写脚本查询每条记录的结果，并匹配营销员和用户是否对应。7.配置客户清单的type和后台Activity配置或者代码里面的type一致","text":"BD赢家拓客上线检查数据记录123456781.分享数据tookeen_share2.活动数据tookeen_activity3.所有的数据都要匹配到agent和wxUser4.数据记录三级分类，tookeen_share和tookeen_activty5.试算记录tookeen_calc，source为3表示当月热荐，source为1私人定制， source为2产品分享，insuranceTitle过长会造成客户清单显示不全。6.根据编写脚本查询每条记录的结果，并匹配营销员和用户是否对应。7.配置客户清单的type和后台Activity配置或者代码里面的type一致 上下线时间123456789明确上下线时间，并和项目管理确认该时间是否正确。(1) 代码写在ActFirstAction中的需要在后台Activity配置一栏中， 配置分享，链接，检索以及上下线时间， 其中的下线时间要配置到59分59秒(2) 不在ActFirstAction中的，需要在config里面配置上下线的key， 其中BaseAction中有两个方法，一个是 gameIsStart，一个是gameOutTime， 其中gameIsStart是正常时间配置， gameOutTime会在现有的时间上加上一天 静态资源123451.sit https://sit.tohours.com/salesplus/static/2.uat https://static.tohours.com/salesplus_uat/3.prod https://static.tohours.com/salesplus/4./.jpg/.png/.jpeg/.gif/.css/.js的类型放CDN上，对于引起跨域类型的json或者mp3放服务器， 白鹭引擎做的活动要注意json文件转成action引用。 名片123456名片是否匹配，营销员必须从公众号自己分享才会显示自己的名片，所有点击或者转发别的营销员分享的链接都是别的营销员的信息。&lt;s:include value=&quot;inc-link.jsp&quot;&gt;&lt;/s:include&gt;&lt;s:include value=&quot;inc-card.jsp&quot;&gt;&lt;/s:include&gt;&lt;s:include value=&quot;inc-footer.jsp&quot;&gt;&lt;/s:include&gt; 配置文档1234567项目开发完成，svn上传技术文档，其中包含脚本，配置以及说明文档，以及每日快讯的link地址，脚本文档包含：营销员分享和获客脚本，配置文档包含：时间配置，客户清单配置或者其他特殊配置，按项目来定，说明文档包含：静态页面路径也就是svn的访问地址，项目的访问路径（如https://localhost:8080/salesplus/goodstart/a.action），以及开发者和项目管理的名字 分享1234点对点和朋友圈分享链接是否正确，对于某些点击按钮重新分享的要多测试。(1)代码写在ActFirstAction中的需要在后台Activity中配置分享的东西(2)代码不在ActFirstAction中的需要 在CommonAction中单独配置分享(3)另外页面上要写分享的自定义转发 公用代码123对于 java 公用代码，能复用就复用，对于不确定的方法要询问相关开发人员，不适用则新增或者调整原来代码，达到两个都可以使用。 客户清单1客户清单字段是否匹配，是否正常显示。 测试用例1根据该活动编写相应的场景测试，不同的线不同的账号做测试，并检查数据完整性。 测试报告1测试完毕编写测试报告，比如分享数据结果，活动数据结果。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-01T02:07:52.000Z","updated":"2018-07-09T12:21:34.991Z","comments":false,"path":"2017/08/01/hello-world/","link":"","permalink":"http://yuzhe-tech.com/2017/08/01/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}