{"meta":{"title":"博客|屿哲","subtitle":null,"description":"thinking in island","author":"Yuzhe Von","url":"http://yuzhe-tech.com"},"pages":[{"title":"我没有国度|我没有岛屿","date":"2018-05-22T10:16:00.285Z","updated":"2018-05-22T10:16:00.285Z","comments":false,"path":"myLife/index.html","permalink":"http://yuzhe-tech.com/myLife/index.html","excerpt":"","text":""},{"title":"","date":"2018-05-24T03:04:29.355Z","updated":"2018-05-24T03:04:29.355Z","comments":false,"path":"about/index.html","permalink":"http://yuzhe-tech.com/about/index.html","excerpt":"","text":"微信："},{"title":"categories","date":"2018-05-16T09:32:04.000Z","updated":"2018-05-21T08:38:43.830Z","comments":false,"path":"categories/index.html","permalink":"http://yuzhe-tech.com/categories/index.html","excerpt":"","text":"Java"},{"title":"书签","date":"2018-05-22T07:21:23.548Z","updated":"2018-05-22T07:21:23.548Z","comments":false,"path":"links/index.html","permalink":"http://yuzhe-tech.com/links/index.html","excerpt":"","text":"常用工具 json格式化在线工具 前台API W3CLayUIDatatablesjQuery模板AngularJS SwiperBootstraploading.io 后台API NutzHexoGithubEclipse 阅读 极客学院老D博客老鬼博客"},{"title":"tags","date":"2018-05-16T09:42:39.000Z","updated":"2018-05-16T09:42:39.447Z","comments":true,"path":"tags/index.html","permalink":"http://yuzhe-tech.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Exception-01","slug":"Exception-01","date":"2018-06-04T14:41:15.000Z","updated":"2018-07-04T10:28:46.855Z","comments":false,"path":"2018/06/04/Exception-01/","link":"","permalink":"http://yuzhe-tech.com/2018/06/04/Exception-01/","excerpt":"（一）异常机制中还有一个重要的部分，就是finally, catch后面可以跟finally语句，语法如下所示：try{ //可能抛出异常 }catch(Exception e){ //捕获异常 }finally{ //不管有无异常都执行 }","text":"（一）异常机制中还有一个重要的部分，就是finally, catch后面可以跟finally语句，语法如下所示：try{ //可能抛出异常 }catch(Exception e){ //捕获异常 }finally{ //不管有无异常都执行 } （二）finally内的代码不管有无异常发生，都会执行。具体来说：如果没有异常发生，在try内的代码执行结束后执行。如果有异常发生且被catch捕获，在catch内的代码执行结束后执行如果有异常发生但没被捕获，则在异常被抛给上层之前执行。由于finally的这个特点，它一般用于释放资源，如数据库连接、文件流等。 try/catch/finally语法中，catch不是必需的，也就是可以只有try/finally，表示不捕获异常，异常自动向上传递，但finally中的代码在异常发生后也执行。 （三）finally语句有一个执行细节，如果在try或者catch语句内有return语句，则return语句在finally语句执行结束后才执行，但finally并不能改变返回值，我们来看下代码：public static int test(){ int ret = 0; try{ return ret; }finally{ ret = 2; } } 这个函数的返回值是0，而不是2，实际执行过程是，在执行到try内的return ret;语句前，会先将返回值ret保存在一个临时变量中，然后才执行finally语句，最后try再返回那个临时变量，finally中对ret的修改不会被返回。 （四）如果在finally中也有return语句呢？try和catch内的return会丢失，实际会返回finally中的返回值。finally中有return不仅会覆盖try和catch内的返回值，还会掩盖try和catch内的异常，就像异常没有发生一样，比如说：public static int test(){ int ret = 0; try{ int a = 5/0; return ret; }finally{ return 2; } } 以上代码中，5/0会触发ArithmeticException，但是finally中有return语句，这个方法就会返回2，而不再向上传递异常了。 （五）finally中不仅return语句会掩盖异常，如果finally中抛出了异常，则原异常就会被掩盖，看下面代码：public static void test(){ try{ int a = 5/0; }finally{ throw new RuntimeException(&quot;hello&quot;); } } finally中抛出了RuntimeException，则原异常ArithmeticException就丢失了。 一般而言，为避免混淆，应该避免在finally中使用return语句或者抛出异常，如果调用的其他代码可能抛出异常，则应该捕获异常并进行处理。","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"Spring","slug":"spring01","date":"2017-11-04T15:05:47.000Z","updated":"2018-07-04T10:29:49.851Z","comments":false,"path":"2017/11/04/spring01/","link":"","permalink":"http://yuzhe-tech.com/2017/11/04/spring01/","excerpt":"一、Spring概述开源的，用来简化企业级应用开发的应用开发框架。 我们学习Spring框架的最终目的是用它整合Struts2、Hibernate框架（SSH）。","text":"一、Spring概述开源的，用来简化企业级应用开发的应用开发框架。 我们学习Spring框架的最终目的是用它整合Struts2、Hibernate框架（SSH）。 1.1 Spring框架的作用Spring框架主要负责技术整合（可以整合很多技术），该框架提供IoC和AOP机制，基于这些特性整合，可以降低系统组件之间的耦合度，便于系统组件的维护、扩展和替换。 1.1.1 简化开发: spring对常用的一些api（比如jdbc）做了封装，​ 这样，代码会大大简化，而且代码质量也会提高（比如，使用​ spring jdbc访问数据库，就不用考虑获取连接与关闭连接）。 1.1.2 解耦: spring可以帮我们管理对象（帮我们创建对象并且管理​ 对象之间依赖关系)。这样一来，软件更容易维护。 1.1.3 集成: spring可以集成其它的一些框架（比如，集成任务调度的框架 Quartz等等）。 1.2 Spring框架的优点其实与Spring框架的作用相同： 在SSH中，主要是利用Spring容器管理我们程序中的Action、DAO等组件，通过容器的IoC机制，可以降低Action、DAO之间的耦合度（关联度），利用AOP进行事务管理等共通部分的处理。 在SSH中，Struts2主要是利用它的控制器，而不是标签、表达式；Hibernate主要利用它的数据库访问；Spring主要是利用它的整合。 1.3 Spring框架的容器​ Spring框架中的一个核心模块，用来管理对象。​ 注：管理对象：指的是创建对象、初始化、销毁以及管理对象之间​ 的依赖关系。 Spring框架的核心是提供了一个容器（是我们抽象出来的，代指后面的类型）。该容器类型是BeanFactory(接口)或ApplicationContext（接口）（建议用这个类型，它是BeanFactory的子类，功能更多）。 二、Spring容器的基本应用2.1如何将一个Bean组件交给Spring容器1）Bean组件其实就是个普通的Java类！ 2）方法：在applicationContext.xml中添加以下定义，见2.6案例中step4。 &lt;bean id=&quot;标识符&quot; class=&quot;Bean组件类型&quot;&gt;&lt;/bean&gt; 2.2如何获取Spring容器对象和Bean对象1）实例化容器： ApplicationContext ac=new ClassPathXmlApplicationContext(“/applicationContext.xml”); //FileSystemXmlApplicationContext(“”);//去指定的磁盘目录找，上面的为去Class路径找 2）利用getBean(“标识符”)方法获取容器中的Bean对象。见2.6案例中step5。 2.3如何控制对象创建的模式Spring支持singleton（单例）和prototype（原型，非单例）两种模式。 默认是singleton模式，可以通过的scope属性修改为prototype模式。以后在Web程序中，通过扩展可以使用request、session等值。见2.6案例中step4、step7。 例如： u 注意事项：对于NetCTOSS项目，一个请求创建一个Action，所以用Spring时必须指明prototype，否则默认使用singleton会出问题。而DAO则可用singleton模式。 2.4 Bean对象创建的时机1）singleton模式的Bean组件是在容器实例化时创建。 2）prototype模式是在调用getBean()方法时创建。 3）singleton模式可以使用元素的lazy-init=”true”属性将对象的创建时机推迟到调用getBean()方法。也可以在（根元素）中使用default-lazy-init=”false”推迟所有单例Bean组件的创建时机。见2.6案例中step3、step4。 例如： &lt;beans ...... default-lazy-init=&quot;false&quot;&gt;&lt;/beans&gt; 2.5为Bean对象执行初始化和销毁方法1）初始化：①可以利用元素的init-method=”方法名”属性指定初始化方法。 ②指定的初始化方法是在构造方法调用后自动执行。若非单例模式，则每创建一个对象，则执行一次初始化方法（单例、非单例模式都可）。见2.6案例中step3、step4。 u 注意事项： v 初始化的三种方式：写构造方法中；或写{ }中（代码块）；Spring框架中元素写init-method=”方法名”属性。 v 初始化不能用static{ }，它是类加载调用，比创建对象要早。 2）销毁：①可以利用元素的destroy-method=”方法名”属性执行销毁方法。 ②指定的销毁方法是在容器关闭时触发，而且只适用于singleton模式的组件（只能为单例模式）。见2.6案例中step3、step4、step6。 2.6案例：Spring框架的使用以及2.1节-2.5节整合测试step1：导入Spring开发包：spring.jar、commons-logging.jar和配置文件：applicationContext.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; step2：在org.tarena.dao包下，创建接口CostDAO，添加两个方法 public void delete(); public void save(); step3：在org.tarena.dao包下，创建JdbcCostDAO类，并实现CostDAO接口 public JdbcCostDAO(){ System.out.println(“创建CostDAO对象”); } public void myinit(){ System.out.println(“初始化CostDAO对象”); } public void mydestroy(){ System.out.println(“销毁CostDAO对象”); } public void delete() { System.out.println(“利用JDBC技术实现删除资费记录”); } public void save() { System.out.println(“利用JDBC技术实现保存资费记录”); } step4：在applicationContext.xml配置文件中，将Bean组件（Java类）交给Spring容器 step5：在org.tarena.test包下，创建TestApplicationContext类，获取Spring容器对象，并测试 @Test public void test1(){ String conf=”/applicationContext.xml”; ​ ApplicationContext ac=new ClassPathXmlApplicationContext(conf);//实例化容器 ​ CostDAO costDAO=(CostDAO)ac.getBean(“jdbcCostDAO”);//获取Bean对象 ​ costDAO.save(); costDAO.delete(); } step6：在TestApplicationContext类中添加方法，测试销毁对象 @Test /*关闭容器才会触发销毁，但关闭容器方法封装在AbstractApplicationContext类中 / public void test2(){ String conf=”/applicationContext.xml”; ​ ApplicationContext ac=new ClassPathXmlApplicationContext(conf); ​ AbstractApplicationContext ac=new ClassPathXmlApplicationContext(conf); ​ CostDAO costDAO=(CostDAO)ac.getBean(“jdbcCostDAO”); ac.close(); } step7：在TestApplicationContext类中添加方法，测试单例 ​ @Test ​ public void test3(){ String conf=”/applicationContext.xml”; ​ ApplicationContext ac= new ClassPathXmlApplicationContext(conf); ​ CostDAO costDAO1=(CostDAO)ac.getBean(“jdbcCostDAO”); ​ CostDAO costDAO2=(CostDAO)ac.getBean(“jdbcCostDAO”); ​ System.out.println(costDAO1==costDAO2);//true，所以Spring默认为单例模式 }","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"阿里巴巴Java开发手册","slug":"阿里开发规范","date":"2017-11-04T15:05:47.000Z","updated":"2018-07-05T05:31:15.154Z","comments":false,"path":"2017/11/04/阿里开发规范/","link":"","permalink":"http://yuzhe-tech.com/2017/11/04/阿里开发规范/","excerpt":"","text":"《阿里巴巴Java开发手册》最新详尽版： 说明： 该书是阿里内部Java工程师所遵循的开发规范，涵盖编程规约、单元测试规约、异常日志规约、MySQL规约、工程规约、安全规约等。让我们一起码出高效、码出质量。","categories":[{"name":"Java","slug":"Java","permalink":"http://yuzhe-tech.com/categories/Java/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-11-01T02:07:52.000Z","updated":"2018-07-04T10:30:49.585Z","comments":false,"path":"2017/11/01/hello-world/","link":"","permalink":"http://yuzhe-tech.com/2017/11/01/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}